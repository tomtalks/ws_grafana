# Metrics Dashboard

## Configuration

### Prometheus

Nous allons ajouter une *DataSource* `Prometheus` pour afficher les m√©triques issues d'applications Java.

![DataSource](image-14.png){width="350"}

| Information     | Value       |
|-----------------|-------------|
| Name            | prometheus  |
| URL             | http://prometheus:9090 |
| Authentication methods | No Authentication |
| Skip TLS certificate validation    | true     |

üòá Comme tout est en local, nous n'avons pas d'authentification √† ajouter. Ni de gestion des TLS.

Vous pouvez d'ailleurs vous connecter √† cette instance qui tourne en local [ici](http://localhost:9090){target="_blank"}

!!!success
    ![DS ok](image-15.png)

### La fonction explore

Avant de cr√©er notre dashboard, on peut facilement explorer les donn√©es disponibles via cette *DataSource* en cliquant sur le bouton `Explore data` en haut √† droite qui redirige vers le menu `Explore`. On retrouve le m√™me type de formulaire que pour les requ√™tes d'un widget.

On peut facilement voir les m√©triques disponibles via le `metrics browser`

![Metrics browser](image-16.png){width="300"}

Mais aussi gr√¢ce √† l'auto-compl√©tion:

![Auto-complete](image-17.png)

Une visualisation par d√©faut est propos√©e pour afficher les donn√©es:

![Viz](image-6.png)

Et les donn√©es brutes:

![Raw date](image-7.png)

### Quelques mots sur PromQL

Prometheus utilise le langage [PromQL](https://prometheus.io/docs/prometheus/latest/querying/basics/){target="_blank"} pour `Prometheus Query Language` ...

Une requ√™te *PromQL* retourne une liste d'enregistrements, ils sont compos√©s des √©l√©ments suivants :

* le nom de la m√©trique
* les labels associ√©s √† la m√©trique
* la valeur de la m√©trique
* le timestamp

La cl√© primaire d'un enregistrement est la combinaison du nom de la m√©trique et des labels associ√©s.

Les labels et le nom de la m√©trique sont en partie d√©finis par la source de donn√©es. Il est aussi possible d'ajouter des r√®gles dans Prometheus pour ajouter / modifier / supprimer des labels.

Par d√©faut, Prometheus va ajouter des labels pour donner des informations sur la source des donn√©es (le label **job** par exemple).

C'est tr√®s utile pour s√©parer les donn√©es de plusieurs sources (ex environnement de production / pr√©prod).

// **TODO** : Pas clair, illustrer avec un exemple ?

Le langage de requ√™tage *PromQL* permet de faire des op√©rations sur les donn√©es. On utilisera ici l'op√©rateur d'agr√©gation [sum](https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators){target="_blank"}

## Le dashboard

D√©marrons maintenant le lab : cr√©er un nouveau Dashboard nomm√© *Dashboard de monitoring*.

### Monitoring de la m√©moire

Ajouter une nouvelle visualisation pour afficher les m√©triques de m√©moire de notre application Java en choisissant la *DataSource* `prometheus` pr√©c√©demment cr√©√©e.

On va utiliser la m√©trique suivante : *jvm_memory_used_bytes* pour configurer la *Query*.

En sp√©cifiant uniquement le nom de la m√©trique, on remonte l'ensemble des valeurs associ√©es √† cette m√©trique.

!!!success "Les m√©triques sont bien affich√©es"
    ![Metrics](image-18.png)

Prometheus utilise des *Labels* pour donner plus d'informations sur une m√©trique

![Details](image-19.png)

#### Configuration du widget

![donn√©es brutes](image.png)

Pour le moment, notre widget n'est pas particuli√®rement lisible (Toutes les informations m√©moire de nos JVM sont retourn√©es sur le m√™me graphe). On va ajouter des informations pour le rendre plus lisible.

On souhaite afficher les m√©moires [Heap / Non Heap](https://medium.com/@kiarash.shamaii/understanding-javas-memory-model-and-the-inner-workings-of-garbage-collection-f73e2b399605){target="_blank"} pour le service *lumbercamp* pour suivre l'√©volution de la m√©moire.

En observant les labels pour identifier ceux qui sont les plus int√©ressants et modifier le widget en cons√©quence:

* Filtrer pour n'afficher que les infos en lien avec le service *lumbercamp*.
* Modifier les unit√©s du graphe pour que les valeurs soient en `bytes`
* Afficher **uniquement 2** courbes repr√©sentant la m√©moire de type *heap* et la m√©moire de type *non_heap*

???tip "Un indice"
    Le label `jvm_memory_type` permet de faire la diff√©rence entre la **heap** et la **non_heap**.

???tip "Indice 2"
    Attention `jvm_memory_pool_name="Metaspace"` est d√©j√† la somme des pools : "CodeHeap 'non-nmethods'" "CodeHeap 'non-profiled nmethods'" "CodeHeap 'profiled nmethods'" "Compressed Class Space"...

!!!success
    ![Memory monitoring](image-20.png)

???danger "Spoiler la solution est l√†"
    Il faut faire 2 *Query* :

    * Une pour la partie **heap** en sommant toutes les infos en lien avec un `jvm_memory_type` = `heap`
    ![Heap](image-21.png)

    * Une pour la partie **non_heap** en filtrant uniquement sur le `jvm_memory_pool_name` = `Metaspace` du fait qu'il repr√©sente d√©j√† la somme des m√©moires *non_heap*
    ![Non_heap](image-22.png)

    * Le fait de pouvoir ajouter de multiples queries sur un m√™me graphe permet d'afficher des donn√©es avec des modes de calcul diff√©rents.

### Monitoring du CPU

On va aussi afficher la consommation CPU de notre application *lumbercamp*.

Pour cela, on va utiliser la m√©trique `jvm_cpu_time_seconds_total`.

#### Les m√©triques de type `total`

Petit probl√®me ici, la valeur correspond √† la somme des temps CPU utilis√©s par l'ensemble des threads de notre application depuis le d√©marrage.

üõü `PromQL Rate` √† la rescousse

// TODO : un peu magique le `rate`. Est-ce qu'il faut expliquer un peu la th√©orie maths ?

On aimerait avoir la consommation par minute. Pour cela, il existe des [fonctions](https://prometheus.io/docs/prometheus/latest/querying/functions/){target="_blank"} avec **PromQL** notamment [rate](https://prometheus.io/docs/prometheus/latest/querying/functions/#rate){target="_blank"} qui permet de calculer la d√©riv√©e d'une s√©rie temporelle.

Cette fonction travaille avec un **range-vector**. Le range-vector est un vecteur de valeurs sur une p√©riode donn√©e. Ainsi, pour calculer la d√©riv√©e d'une s√©rie temporelle, il faut sp√©cifier une p√©riode.

On utilisera les ranges **[1m]** **[5m]** **[15m]** qui vont calculer un rate par seconde en se basant sur l'ensemble des donn√©es des *X* derni√®res minutes pour chaque point de donn√©es. On reproduit ainsi l'affichage du `top` unix.

???tip "Astuce"
    Vous pouvez facilement dupliquer une *Query* pour ne changer que l'intervalle souhait√©

!!!success
    L'objectif est d'obtenir le graphe suivant avec 3 courbes pour les rates **[1m]**, **[5m]** et **[15m]**

    ![CPU monitoring](image-26.png)

???danger "Spoiler la solution est l√†"
    Il faut faire 3 *Query* en changeant l'interval

    ![CPU](image-23.png)

## Filtrage par service

Comme on l'a fait pour le dashboard Postgres, il serait pratique de pouvoir dynamiquement filtrer les informations affich√©es par les widgets.

Pour ce dashboard, on va donc ajouter une variable permettant de changer le nom du service pour lequel on souhaite avoir les m√©triques.

Objectifs:

* Cr√©er une variable `prom_service_name` bas√©e sur la *DataSource* `prometheus` permettant de r√©cup√©rer les services monitor√©s par Prometheus
* Modifier les 2 widgets pour qu'il prenne en compte cette nouvelle variable dans leurs *Query* et dans leur titre

!!!success
    ![Filtered by service](image-29.png)

???danger "Spoiler la solution est l√†"
    * La configuration de la variable

    ![Variable](image-27.png)

    * Un exemple de *Query* modifi√©e
    ![Variable in query](image-28.png)

Ok c'est pas mal mais allons plus loin :

**üõ´ Prochaine √©tape : Dashboard Advanced [‚û°Ô∏è](../dashboard-metrics/advanced.md)**
